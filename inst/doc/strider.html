<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Timothy H. Keitt" />

<meta name="date" content="2017-11-18" />

<title>The Strider Package</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">The Strider Package</h1>
<h4 class="author"><em>Timothy H. Keitt</em></h4>
<h4 class="date"><em>2017-11-18</em></h4>



<p>“I don’t think he knows about second breakfast” - Meriadoc ‘Merry’ Brandybuck</p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The <a href="http://en.cppreference.com/w/">C++ standard library</a> introduced generic algorithms that operate on a sequences defined by begin-end iterator-pairs. These generic algorithms can be used to replace C-style for-loops over indices. They are thought to reduce common code bugs resulting from off-by-n indexing errors that can result in buffer overruns and other illogical behavior. Applying the standard library algorithms is often straightforward for simple sequences bounded by iterators. When working with multidimensional data like matrices however, many authors revert to computing indices, either because it is more explicit and therefor easier to implement or because the multidimensional data structures do not offer pre-defined iterators.</p>
<p>The difficulty applying the standard library algorithms to multidimensional data stems from the fact that successive dimensions must follow leading dimensions and this necessitates skips when iterating. Solving this requires a strided iterator that skips over intermediate memory locations when incrementing or decrementing. Having myself often reverted to indices when implementing algorithms on multidimensional data, while simultaneously wishing for more consistency with the standard library, I decided to implement a strided pointer class and wrap it in the new R library <strong>strider</strong>. The header is installed with the package, so it can be used by other packages via the LinkingTo directive in the DESCRIPTION file. The header has no dependencies on R and so can be used separately.</p>
<div id="replacing-index-loops-with-standard-library-algorithms" class="section level3">
<h3>Replacing index loops with standard library algorithms</h3>
<p>As a prelude to using the <strong>strided_iterator</strong> class, I start out with an example of vector convolution because it is one of the original examples in the <a href="https://github.com/RcppCore/Rcpp">Rcpp</a> documentation, which I have copied verbatim here. I have place some definitions into a header file whose contents can be found in the RMarkdown source file used to generate this output. Otherwise, all compiler settings were left at their default values.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(BH)]]</span>
<span class="co">// [[Rcpp::depends(strider)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">&lt;vignette.h&gt;</span>

<span class="co">// [[Rcpp::export]]</span>
NumericVector
convolve_cpp(<span class="at">const</span> NumericVector&amp; a,
             <span class="at">const</span> NumericVector&amp; b) {
  <span class="co">// Declare loop counters, and vector sizes</span>
  <span class="dt">int</span> i, j,
      na = a.size(), nb = b.size(),
      nab = na + nb - <span class="dv">1</span>;
  <span class="co">// Create vector filled with 0</span>
  NumericVector ab(nab);
  <span class="co">// Crux of the algorithm</span>
  <span class="cf">for</span>(i = <span class="dv">0</span>; i &lt; na; i++) {
    <span class="cf">for</span>(j = <span class="dv">0</span>; j &lt; nb; j++) {
          ab[i + j] += a[i] * b[j];
    }
  }
  <span class="co">// Return result</span>
  <span class="cf">return</span> ab;
}</code></pre></div>
<p>The next code block shows my translation using the standard library transform algorithm. This version eschews integer indexes for incrementing iterators along the input and output vectors.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(BH)]]</span>
<span class="co">// [[Rcpp::depends(strider)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">&lt;vignette.h&gt;</span>

<span class="co">// [[Rcpp::export]]</span>
NumericVector
stl_algo_convolve(<span class="at">const</span> NumericVector&amp; a,
                  <span class="at">const</span> NumericVector&amp; b) {
  <span class="co">// Declare vector sizes</span>
  <span class="dt">int</span>
    na = a.size(), nb = b.size(), 
    nab = na + nb - <span class="dv">1</span>;
  <span class="co">// Create vector filled with 0</span>
  NumericVector ab(nab);
  <span class="co">// Crux of the algorithm</span>
  transform(begin(a), end(a),
            begin(ab), begin(ab),
            [&amp;](<span class="at">const</span> <span class="dt">double</span>&amp; t, <span class="dt">double</span>&amp; u){
              transform(begin(b), end(b), &amp;u, &amp;u,
                        [&amp;](<span class="at">const</span> <span class="dt">double</span>&amp; v, <span class="at">const</span> <span class="dt">double</span>&amp; w){
                          <span class="cf">return</span> w + t * v; });
              <span class="cf">return</span> u; });
  <span class="co">// Return result</span>
  <span class="cf">return</span> ab;
}</code></pre></div>
<p>While the code is certainly more busy, replacing explicit loops with standard library algorithms is considered by some to be a best-practice that is less susceptible to indexing errors and buffer overruns.</p>
<p>C++11 introduced range-based for-loops that many of the advantages of the standard library algorithms in terms of avoiding indexing errors and are simpler and somewhat more natural to reason about.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(BH)]]</span>
<span class="co">// [[Rcpp::depends(strider)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">&lt;vignette.h&gt;</span>

<span class="co">// [[Rcpp::export]]</span>
NumericVector
range_loop_convolve(<span class="at">const</span> NumericVector&amp; a,
                    <span class="at">const</span> NumericVector&amp; b) {
  <span class="co">// Declare vector sizes</span>
  <span class="dt">int</span>
    na = a.size(), nb = b.size(), 
    nab = na + nb - <span class="dv">1</span>;
  <span class="co">// Create vector filled with 0</span>
  NumericVector ab(nab);
  <span class="co">// Crux of the algorithm</span>
  <span class="kw">auto</span> t = &amp;ab[<span class="dv">0</span>];
  <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; u : a)
  {
    <span class="kw">auto</span> v = t++;
    <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; w : b)
      *v++ += u * w;
  }
  <span class="co">// Return result</span>
  <span class="cf">return</span> ab;
}</code></pre></div>
<p>The main difference here is we have to manually increment the output iterator. That could be solved using a zip iterator adapter. (Convenient tuple syntax for this case is available in C++17.) Nonetheless, this example demonstrates how expressive range-based for-loops can be while avoiding explicit indices.</p>
<p>There is no particular performance advantage to avoiding indices, so the choice is largely a matter of taste. Modern compilers will produce similar if not the exact same instructions regardless of the type of loop. Benchmarking comparisons can however point out problems with a particular implementation. It is useful to recall that benchmark differences within <span class="math inline">\(\pm 10\%\)</span> are likely meaningless and results will vary in different environments. With two vectors of length <span class="math inline">\(10^4\)</span>, I get the following run times for the different loop implementations.</p>
<table>
<caption>Evaluations per second</caption>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">median</th>
<th align="right">relative</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">stl_algo_convolve(a, b)</td>
<td align="right">101.7</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">range_loop_convolve(a, b)</td>
<td align="right">101.5</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="left">convolve_cpp(a, b)</td>
<td align="right">100.8</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="strided_iterator-and-strided_range" class="section level2">
<h2>Strided_iterator and strided_range</h2>
<p>The workhorse class in the <strong>strider</strong> package is <strong>strided_iterator</strong>, which inherits from the <a href="http://www.boost.org/doc/libs/release/libs/iterator/">Boost iterator adaptor</a> class. It merely advances by a specified stride when incremented. It is currently possible to use negative strides, however this is not tested. The strided iterator will conform to the same iterator category and support the same expressions as the iterator that is adapted. A second class, <strong>strided_range</strong> exists solely to construct begin and end iterators over a strided range.</p>
<p>Users will generally only need to call one or both of two auxiliary functions with the following definitions:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">inline</span> strided_iterator&lt;T&gt;
make_strided(T iter,
             <span class="kw">typename</span> iterator_traits&lt;T&gt;::<span class="dt">difference_type</span> stride = <span class="dv">0</span>,
             <span class="kw">typename</span> iterator_traits&lt;T&gt;::<span class="dt">difference_type</span> strides = <span class="dv">0</span>);

<span class="kw">template</span>&lt;<span class="kw">typename</span> T&gt;
<span class="kw">inline</span> strided_range&lt;T&gt;
make_strided_range(T iter,
                   <span class="kw">typename</span> iterator_traits&lt;T&gt;::<span class="dt">difference_type</span> stride,
                   <span class="kw">typename</span> iterator_traits&lt;T&gt;::<span class="dt">difference_type</span> strides);</code></pre></div>
<p>The <code>make_strided</code> function converts an ordinary iterator to a strided iterator. The stride length is determined by the <code>stride</code> argument. As a convenience, the <code>strides</code> argument can be used to advance the supplied iterator <code>strides</code> <span class="math inline">\(\times\)</span> <code>stride</code> steps. This is useful in creating an end-sentinel iterator for a buffer that does not provide its own <code>end</code> function. Examples of this usage can be found below.</p>
<p>The <code>make_strided_range</code> function creates a <code>strided_range</code> object with <code>begin</code> and <code>end</code> methods. Both <code>stride</code> and <code>strides</code> are required to define the spanned range.</p>
<div id="striding-over-matrix-margins" class="section level3">
<h3>Striding over matrix margins</h3>
<p>As a minimal example, consider computing the column sums of a matrix. I provide three example implementations using indices, <code>make_strided</code> and <code>make_strided_range</code>.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(BH)]]</span>
<span class="co">// [[Rcpp::depends(strider)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">&lt;vignette.h&gt;</span>

<span class="co">// [[Rcpp::export]]</span>
NumericVector indx_col_sum(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span>
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc, <span class="fl">0.0</span>);
  <span class="cf">for</span> (<span class="dt">int</span> c = <span class="dv">0</span>; c != nc; ++c)
    <span class="cf">for</span> (<span class="dt">int</span> r = <span class="dv">0</span>; r != nr; ++r)
      res[c] += x(r, c);
  <span class="cf">return</span> res;
}

<span class="co">// [[Rcpp::export]]</span>
NumericVector strided_col_sum(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span> nr = x.nrow();
  NumericVector res(x.ncol());
  transform(make_strided(begin(x), nr), make_strided(end(x)), begin(res),
            [&amp;](<span class="at">const</span> <span class="dt">double</span>&amp; v){ <span class="cf">return</span> accumulate(&amp;v, &amp;v + nr, <span class="fl">0.0</span>); });
  <span class="cf">return</span> res;
}

<span class="co">// [[Rcpp::export]]</span>
NumericVector range_col_sum(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span>
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc);
  <span class="kw">auto</span> t = res.begin();
  <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; u : make_strided_range(begin(x), nr, nc))
  {
    <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; v : make_strided_range(&amp;u, <span class="dv">1</span>, nr)) *t += v;
    ++t;
  }
  <span class="cf">return</span> res;
}</code></pre></div>
<p>In this case, owing to the column-major memory layout of R matrices, the STL <code>transform</code> algorithm combined with <code>make_strided</code> is the most compact in terms of code. Furthermore, the strided iterator is incremented in the outer loop meaning the scanning of the matrix is in the optimal order. The performance of these three implementations are equivalent, as is R’s built in <code>colSumms</code> implemented in C.</p>
<table>
<caption>Evaluations per second</caption>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">median</th>
<th align="right">relative</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">strided_col_sum(x)</td>
<td align="right">1063.9</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">colSums(x)</td>
<td align="right">1039.3</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="left">indx_col_sum(x)</td>
<td align="right">1032.1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">range_col_sum(x)</td>
<td align="right">1030.3</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
</div>
<div id="row-sums" class="section level3">
<h3>Row sums</h3>
<p>Summing over rows is more interesting because R matrices are stored in column-major format. That means that looping over a row will skip from column to column by-passing all the rows in between. This non-local memory access is a drag on performance. Four implementations of the row-summing algorithm are given below.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(BH)]]</span>
<span class="co">// [[Rcpp::depends(strider)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">&lt;vignette.h&gt;</span>

<span class="co">// [[Rcpp::export]]</span>
NumericVector indx_row_sum(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span>
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nr, <span class="fl">0.0</span>);
  <span class="cf">for</span> (<span class="dt">int</span> c = <span class="dv">0</span>; c != nc; ++c)
    <span class="cf">for</span> (<span class="dt">int</span> r = <span class="dv">0</span>; r != nr; ++r)
      res[r] += x(r, c);
  <span class="cf">return</span> res;
}

<span class="co">// [[Rcpp::export]]</span>
NumericVector strided_row_sum(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span>
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nr);
  transform(begin(x), begin(x) + nr, begin(res), [&amp;](<span class="at">const</span> <span class="dt">double</span>&amp; v)        {
    <span class="cf">return</span> accumulate(make_strided(&amp;v, nr), make_strided(&amp;v, nr, nc), <span class="fl">0.0</span>);  });
  <span class="cf">return</span> res;
}

<span class="co">// [[Rcpp::export]]</span>
NumericVector strided_row_sum2(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span> nr = x.nrow();
  NumericVector res(nr, <span class="fl">0.0</span>);
  for_each(make_strided(begin(x), nr), make_strided(end(x)),
           [&amp;](<span class="at">const</span> <span class="dt">double</span>&amp; y)                                {
             transform(&amp;y, &amp;y + nr, begin(res), begin(res),
                       [](<span class="at">const</span> <span class="dt">double</span>&amp; a, <span class="at">const</span> <span class="dt">double</span>&amp; b)    {
                         <span class="cf">return</span> a + b;                         });});
  <span class="cf">return</span> res;
}

<span class="co">// [[Rcpp::export]]</span>
NumericVector range_row_sum(<span class="at">const</span> NumericMatrix&amp; x)
{
  <span class="kw">auto</span>
    nr = x.nrow(),
    nc = x.ncol();
  NumericVector res(nc);
  <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; u : make_strided_range(begin(x), nr, nc))
  {
    <span class="kw">auto</span> t = begin(res);
    <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; v : make_strided_range(&amp;u, <span class="dv">1</span>, nr)) *t++ += v;
  }
  <span class="cf">return</span> res;
}</code></pre></div>
<p>Again, the <code>transform</code> with <code>accumulate</code> implementation is compact, but here the strided iterator is in the inner loop causing poor memory locality. The alternative implementation uses <code>for_each</code> with <code>make_strided</code> to skip to the top of each column and then uses <code>transform</code> to accumulate the values. The final range-based version is equivalent to the <code>for_each</code> with <code>transform</code> version.</p>
<p>The benchmark results show that indeed placing the strided iterator in the inner loop gives poor results. The index-based, range-based and <code>for_each</code>-<code>transform</code> version are all equivalent in efficiency. Interestingly, R’s built in <code>rowSums</code> is several times slower, most likely indicating that the column index is incremented in the inner loop.</p>
<table>
<caption>Evaluations per second</caption>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">median</th>
<th align="right">relative</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">strided_row_sum2(x)</td>
<td align="right">1851.6</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">range_row_sum(x)</td>
<td align="right">1849.0</td>
<td align="right">1.0</td>
</tr>
<tr class="odd">
<td align="left">indx_row_sum(x)</td>
<td align="right">1826.5</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">strided_row_sum(x)</td>
<td align="right">516.3</td>
<td align="right">0.3</td>
</tr>
<tr class="odd">
<td align="left">rowSums(x)</td>
<td align="right">483.4</td>
<td align="right">0.3</td>
</tr>
</tbody>
</table>
</div>
<div id="d-convolution" class="section level3">
<h3>2D convolution</h3>
<p>A much better demonstration of the strided approach is to compute the 2-dimensional convolution. This requires four nested loops and much more expensive indexing calculations. Furthermore, because C++ does not provide a bivariate index operators, accessing 2D data structures requires defining a new method and the details of this method will strongly determine overhead. In the strided approach, we simply walk the output matrix by iteration, so no indexing is required.</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[Rcpp::depends(BH)]]</span>
<span class="co">// [[Rcpp::depends(strider)]]</span>
<span class="co">// [[Rcpp::plugins(cpp11)]]</span>

<span class="pp">#include </span><span class="im">&lt;vignette.h&gt;</span>

<span class="co">// [[Rcpp::export]]</span>
NumericMatrix
convolve2_cpp(<span class="at">const</span> NumericMatrix&amp; a,
              <span class="at">const</span> NumericMatrix&amp; b)
{
  <span class="dt">int</span>
    nra = a.nrow(), nca = a.ncol(),
    nrb = b.nrow(), ncb = b.ncol();
  NumericMatrix ab(nra + nrb - <span class="dv">1</span>, nca + ncb - <span class="dv">1</span>);
  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i != nca; ++i)
    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j != ncb; ++j)
      <span class="cf">for</span> (<span class="dt">int</span> k = <span class="dv">0</span>; k != nra; ++k)
        <span class="cf">for</span> (<span class="dt">int</span> l = <span class="dv">0</span>; l != nrb; ++l)
          ab(k + l, i + j) += a(k, i) * b(l, j);
  <span class="cf">return</span> ab;
}

<span class="co">// [[Rcpp::export]]</span>
NumericMatrix
range_loop_convolve2(<span class="at">const</span> NumericMatrix&amp; a,
                     <span class="at">const</span> NumericMatrix&amp; b)
{
  <span class="dt">int</span>
    nra = a.nrow(), nca = a.ncol(),
    nrb = b.nrow(), ncb = b.ncol(),
    nrab = nra + nrb - <span class="dv">1</span>,
    ncab = nca + ncb - <span class="dv">1</span>;
  NumericMatrix ab(nrab, ncab);
  <span class="kw">auto</span> iter1 = make_strided(begin(ab), nrab);
  <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; t : make_strided_range(begin(a), nra, nca))    {
    <span class="kw">auto</span> iter2 = make_strided(&amp;*iter1++, nrab);
    <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; u : make_strided_range(begin(b), nrb, ncb))  {
      <span class="kw">auto</span> iter3 = &amp;*iter2++;
      <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; v : make_strided_range(&amp;t, <span class="dv">1</span>, nra))        {
        <span class="kw">auto</span> iter4 = iter3++;
        <span class="cf">for</span> (<span class="kw">auto</span>&amp;&amp; w : make_strided_range(&amp;u, <span class="dv">1</span>, nrb))      {
          *iter4++ += v * w;                                  }}}}
  <span class="cf">return</span> ab;
}</code></pre></div>
<p>As a quick test, I check whether the convolution is invariant to the delta function as required.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>,
             <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>), <span class="dv">2</span>, <span class="dv">3</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
b =<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
             <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
             <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,
             <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">4</span>, <span class="dv">3</span>, <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
<span class="kw">convolve2_cpp</span>(a, b)</code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    0    0    0    0
## [2,]    0    0    0    0    0
## [3,]    0    1    2    3    0
## [4,]    0    4    5    6    0
## [5,]    0    0    0    0    0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">range_loop_convolve2</span>(a, b)</code></pre></div>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    0    0    0    0    0
## [2,]    0    0    0    0    0
## [3,]    0    1    2    3    0
## [4,]    0    4    5    6    0
## [5,]    0    0    0    0    0</code></pre>
<p>The output is correct. Here are benchmark results for <span class="math inline">\(50\times50\)</span> random matrices.</p>
<table>
<caption>Evaluations per second</caption>
<thead>
<tr class="header">
<th align="left">expr</th>
<th align="right">median</th>
<th align="right">relative</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">range_loop_convolve2(a, b)</td>
<td align="right">396.5</td>
<td align="right">1.0</td>
</tr>
<tr class="even">
<td align="left">convolve2_cpp(a, b)</td>
<td align="right">329.5</td>
<td align="right">0.8</td>
</tr>
</tbody>
</table>
<p>The strided implementation appears to have a slight advantage, however these results may change on different systems. It is possible the index-offset calculations are making the indexed version slower. The importance of offset calculations should increase with the number of dimensions. It should be noted that these are not the fasted algorithms for performing convolution. If the kernel is separable, each dimension can be convolved individually. For large matrices, Fourier methods are faster still.</p>
</div>
</div>
<div id="conclusions" class="section level2">
<h2>Conclusions</h2>
<p>Experimenting with the C++ standard library algorithms demonstrates that they are often highly efficient and, in some cases, faster than corresponding native R algorithms. However using the standard library algorithms with multidimensional data is challenging and it is quite common for authors to resort to index-based for-loops, which can impede performance and risk indexing errors.</p>
<p>The <strong>strider</strong> package provides a lightweight iterator-adapter that makes using the standard library algorithms straightforward with multidimensional buffers accessible via a pointer or iterator. As long as one knows the dimensions and the memory layout of the data, then any dimension can be scanned by computing a stride and number of strides. When it is possible to scan the data sequentially, maximum performance is attained. Owning to the large number of legacy libraries whose APIs pass raw pointers to structured buffers, I expect that <strong>strider</strong> may find a wide range of applications while also improving code reliability and comprehension.</p>
<hr />
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
